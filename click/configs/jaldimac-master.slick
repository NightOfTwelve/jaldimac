// JaldiMAC Click configuration for testing over ethernet
// Obviously everything is mocked for now!


// ======================================================
// Configuration
// ======================================================

// Router configuration
#define $ROUTER_ETH 00:11:22:33:44:55
#define $ROUTER_IP 192.168.0.1
#define $ROUTER_INTERFACE 192.168.0.1/24

#define $CLIENT_1_IP 192.168.0.2
#define $CLIENT_2_IP 192.168.0.3
#define $CLIENT_3_IP 192.168.0.4
#define $CLIENT_4_IP 192.168.0.5

#define $UDP_PORT_1 5004
#define $UDP_PORT_2 5060

#define $MTU 1500

// Click port names
#define $DATA 0
#define $CONTROL 1
#define $VOIP 2 

#define $OUT 1

#define $ARP_QUERY 0
#define $ARP_REPLY 1
#define $IP 2
#define $OTHER 3

#define $INTERNAL 0
#define $HOST 1

#define $CLIENT_1_DATA 0
#define $CLIENT_1_VOIP 1
#define $CLIENT_2_DATA 2
#define $CLIENT_2_VOIP 3
#define $CLIENT_3_DATA 4
#define $CLIENT_3_VOIP 5
#define $CLIENT_4_DATA 6
#define $CLIENT_4_VOIP 7

#define $LOCALLY_ORIGINATING 254

#define $TOHOST Discard
//#define $TOHOST ToHost(eth0)

// ======================================================
// Components
// ======================================================

// TEMP --- REMOVE THIS --- TEMP

elementclass PullToPush { input -> DelayUnqueue(0) -> output }
elementclass JaldiStripAndClassify { input -> t :: Tee ; t[0] -> [0]output ; t[1] -> [1]output }
elementclass JaldiFairness { input[$DATA] -> PullToPush -> [$DATA]output
			     input[$CONTROL] -> PullToPush -> [$CONTROL]output
			     input[$VOIP] -> PullToPush -> [$VOIP]output }
elementclass JaldiScheduler { input[$DATA] -> PullToPush -> output
			      input[$CONTROL] -> PullToPush -> Discard
			      input[$VOIP] -> PullToPush -> Discard }

// TEMP --- REMOVE THIS --- TEMP

// Queues
elementclass JaldiQueue { input -> Queue(2000) -> output }

// Sources (one from upstream, one from downstream)
upstreamSource :: TimedSource(0.2)
downstreamSource :: TimedSource(0.9)

// Sinks (one to upstream, one to downstream)
upstreamSink :: { input -> upstreamQueue :: JaldiQueue -> TimedSink(0.1) }
downstreamSink :: { input -> downstreamQueue :: JaldiQueue -> TimedSink(0.1) }

// Encapsulation / de-encapsulation
elementclass EthernetToIP
{
	input -> Strip(14)					// Remove Ethernet header
	      -> CheckIPHeader(INTERFACES $ROUTER_INTERFACE)	// Check for legality and annotate
	      -> output
}

elementclass JaldiToIP
{
	jsac :: JaldiStripAndClassify
	input -> jsac
	jsac[$DATA] -> Paint($LOCALLY_ORIGINATING) ->[$DATA]output	// One output for data (IP packets)
	jsac[$CONTROL] -> [$CONTROL]output				// Another output for control info
}

elementclass IPToEthernet
{
	aq :: ARPQuerier($ROUTER_IP, $ROUTER_ETH)
	input[$DATA] -> DecIPTTL -> ipf :: IPFragmenter($MTU)
	ipf -> [$DATA]aq -> output			// Frames and ARP queries go to output
	input[$ARP_REPLY] -> [$ARP_REPLY]aq		// ARP responses come in via input[$ARP-REPLY]
}

// Classifiers
elementclass EthernetClassifier
{
	c :: Classifier(12/0806 20/0001,		// ARP queries
			12/0806 20/0002,		// ARP responses
			12/0800,			// IP packets
			-);				// Other
	
	// This is defined in a verbose manner to clearly denote
	// the names associated with each port.
	input -> c
	c[$ARP_QUERY] -> [$ARP_QUERY]output
	c[$ARP_REPLY] -> [$ARP_REPLY]output
	c[$IP] -> [$IP]output
	c[$OTHER] -> [$OTHER]output
}

elementclass IPClassifier
{
	// For now the number of clients is fixed to 4.
	ic :: IPClassifier(dst host $ROUTER_IP,
			   dst host $CLIENT_1_IP udp port $UDP_PORT_1 or $UDP_PORT_2,
			   dst host $CLIENT_1_IP,
			   dst host $CLIENT_2_IP udp port $UDP_PORT_1 or $UDP_PORT_2,
			   dst host $CLIENT_2_IP,
			   dst host $CLIENT_3_IP udp port $UDP_PORT_1 or $UDP_PORT_2,
			   dst host $CLIENT_3_IP,
			   dst host $CLIENT_4_IP udp port $UDP_PORT_1 or $UDP_PORT_2,
			   dst host $CLIENT_4_IP,
			   -)

	input -> ic
	ic[0] -> $TOHOST						// Send packets for router to linux stack
	ic[1] -> DropBroadcasts -> Paint($CLIENT_1_VOIP) -> [$VOIP]output
	ic[2] -> DropBroadcasts -> Paint($CLIENT_1_DATA) -> [$DATA]output
	ic[3] -> DropBroadcasts -> Paint($CLIENT_2_VOIP) -> [$VOIP]output
	ic[4] -> DropBroadcasts -> Paint($CLIENT_2_DATA) -> [$DATA]output
	ic[5] -> DropBroadcasts -> Paint($CLIENT_3_VOIP) -> [$VOIP]output
	ic[6] -> DropBroadcasts -> Paint($CLIENT_3_DATA) -> [$DATA]output
	ic[7] -> DropBroadcasts -> Paint($CLIENT_4_VOIP) -> [$VOIP]output
	ic[8] -> DropBroadcasts -> Paint($CLIENT_4_DATA) -> [$DATA]output
	ic[9] -> DropBroadcasts -> CheckPaint($LOCALLY_ORIGINATING) -> [$OUT]output
}

// Proxy ARP
elementclass ProxyARP
{
	input -> ARPResponder($ROUTER_INTERFACE $ROUTER_ETH) -> output
}

// Fairness
fairness :: JaldiFairness

// Scheduler
scheduler :: JaldiScheduler


// ======================================================
// Component Graph
// ======================================================

// Forward declarations
ethClassifier :: EthernetClassifier
ipClassifier :: IPClassifier
arpReplyTee :: Tee

// Sources, sinks
upstreamSource -> ethClassifier
ipToEth :: IPToEthernet -> upstreamSink
arpReplyTee[$INTERNAL] -> [$ARP_REPLY]ipToEth
arpReplyTee[$HOST] -> $TOHOST
scheduler -> downstreamSink

downstreamSource -> jToIP :: JaldiToIP
jToIP[$DATA] -> ipClassifier
jToIP[$CONTROL] -> JaldiQueue -> [$CONTROL]fairness

// Classifiers
ethClassifier[$ARP_QUERY] -> ProxyARP -> upstreamSink
ethClassifier[$ARP_REPLY] -> arpReplyTee
ethClassifier[$IP] -> EthernetToIP -> ipClassifier
ethClassifier[$OTHER] -> Discard

ipClassifier[$DATA] -> JaldiQueue -> [$DATA]fairness
ipClassifier[$VOIP] -> JaldiQueue -> [$VOIP]fairness
ipClassifier[$OUT] -> ipToEth

// Core algorithms (fairness, scheduling)
fairness[$DATA] -> JaldiQueue -> [$DATA]scheduler
fairness[$VOIP] -> JaldiQueue -> [$VOIP]scheduler
fairness[$CONTROL] -> JaldiQueue -> [$CONTROL]scheduler
